---
source: iox_query_influxql/src/plan/planner.rs
expression: "plan(\"SHOW TAG KEYS WHERE foo = 'some_foo'\")"
---
Sort: iox::measurement ASC NULLS LAST, tagKey ASC NULLS LAST [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
  Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
    Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
      Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
        Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
          Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
            Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
              Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                  Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                    Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                      Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                        Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                          Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                            Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                              Union [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                                Projection: Dictionary(Int32, Utf8("all_types")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                                  Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                                    Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                                      Projection: make_array(CASE WHEN tag0 > Int32(0) THEN Utf8("tag0") END, CASE WHEN tag1 > Int32(0) THEN Utf8("tag1") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                        Aggregate: groupBy=[[]], aggr=[[sum(CAST(all_types.tag0 IS NOT NULL AS UInt64)) AS tag0, sum(CAST(all_types.tag1 IS NOT NULL AS UInt64)) AS tag1]] [tag0:UInt64;N, tag1:UInt64;N]
                                          Filter: all_types.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [bool_field:Boolean;N, f64_field:Float64;N, i64_field:Int64;N, str_field:Utf8;N, tag0:Dictionary(Int32, Utf8);N, tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), u64_field:UInt64;N]
                                            TableScan: all_types [bool_field:Boolean;N, f64_field:Float64;N, i64_field:Int64;N, str_field:Utf8;N, tag0:Dictionary(Int32, Utf8);N, tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), u64_field:UInt64;N]
                                Projection: Dictionary(Int32, Utf8("cpu")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                                  Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                                    Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                                      Projection: make_array(CASE WHEN cpu > Int32(0) THEN Utf8("cpu") END, CASE WHEN host > Int32(0) THEN Utf8("host") END, CASE WHEN region > Int32(0) THEN Utf8("region") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                        Aggregate: groupBy=[[]], aggr=[[sum(CAST(cpu.cpu IS NOT NULL AS UInt64)) AS cpu, sum(CAST(cpu.host IS NOT NULL AS UInt64)) AS host, sum(CAST(cpu.region IS NOT NULL AS UInt64)) AS region]] [cpu:UInt64;N, host:UInt64;N, region:UInt64;N]
                                          Filter: cpu.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [cpu:Dictionary(Int32, Utf8);N, host:Dictionary(Int32, Utf8);N, region:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), usage_idle:Float64;N, usage_system:Float64;N, usage_user:Float64;N]
                                            TableScan: cpu [cpu:Dictionary(Int32, Utf8);N, host:Dictionary(Int32, Utf8);N, region:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), usage_idle:Float64;N, usage_system:Float64;N, usage_user:Float64;N]
                              Projection: Dictionary(Int32, Utf8("data")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                                Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                                  Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                                    Projection: make_array(CASE WHEN bar > Int32(0) THEN Utf8("bar") END, CASE WHEN foo > Int32(0) THEN Utf8("foo") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                      Aggregate: groupBy=[[]], aggr=[[sum(CAST(data.bar IS NOT NULL AS UInt64)) AS bar, sum(CAST(data.foo IS NOT NULL AS UInt64)) AS foo]] [bar:UInt64;N, foo:UInt64;N]
                                        Filter: data.time >= TimestampNanosecond(1672444800000000000, None) AND foo = Dictionary(Int32, Utf8("some_foo")) [TIME:Boolean;N, bar:Dictionary(Int32, Utf8);N, bool_field:Boolean;N, f64_field:Float64;N, foo:Dictionary(Int32, Utf8);N, i64_field:Int64;N, mixedCase:Float64;N, str_field:Utf8;N, time:Timestamp(Nanosecond, None), with space:Float64;N]
                                          TableScan: data [TIME:Boolean;N, bar:Dictionary(Int32, Utf8);N, bool_field:Boolean;N, f64_field:Float64;N, foo:Dictionary(Int32, Utf8);N, i64_field:Int64;N, mixedCase:Float64;N, str_field:Utf8;N, time:Timestamp(Nanosecond, None), with space:Float64;N]
                            Projection: Dictionary(Int32, Utf8("disk")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                              Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                                Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                                  Projection: make_array(CASE WHEN device > Int32(0) THEN Utf8("device") END, CASE WHEN host > Int32(0) THEN Utf8("host") END, CASE WHEN region > Int32(0) THEN Utf8("region") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                    Aggregate: groupBy=[[]], aggr=[[sum(CAST(disk.device IS NOT NULL AS UInt64)) AS device, sum(CAST(disk.host IS NOT NULL AS UInt64)) AS host, sum(CAST(disk.region IS NOT NULL AS UInt64)) AS region]] [device:UInt64;N, host:UInt64;N, region:UInt64;N]
                                      Filter: disk.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [bytes_free:Int64;N, bytes_used:Int64;N, device:Dictionary(Int32, Utf8);N, host:Dictionary(Int32, Utf8);N, region:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                                        TableScan: disk [bytes_free:Int64;N, bytes_used:Int64;N, device:Dictionary(Int32, Utf8);N, host:Dictionary(Int32, Utf8);N, region:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                          Projection: Dictionary(Int32, Utf8("diskio")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                            Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                              Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                                Projection: make_array(CASE WHEN host > Int32(0) THEN Utf8("host") END, CASE WHEN region > Int32(0) THEN Utf8("region") END, CASE WHEN status > Int32(0) THEN Utf8("status") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                  Aggregate: groupBy=[[]], aggr=[[sum(CAST(diskio.host IS NOT NULL AS UInt64)) AS host, sum(CAST(diskio.region IS NOT NULL AS UInt64)) AS region, sum(CAST(diskio.status IS NOT NULL AS UInt64)) AS status]] [host:UInt64;N, region:UInt64;N, status:UInt64;N]
                                    Filter: diskio.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [bytes_read:Int64;N, bytes_written:Int64;N, host:Dictionary(Int32, Utf8);N, is_local:Boolean;N, read_utilization:Float64;N, region:Dictionary(Int32, Utf8);N, status:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), write_utilization:Float64;N]
                                      TableScan: diskio [bytes_read:Int64;N, bytes_written:Int64;N, host:Dictionary(Int32, Utf8);N, is_local:Boolean;N, read_utilization:Float64;N, region:Dictionary(Int32, Utf8);N, status:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None), write_utilization:Float64;N]
                        Projection: Dictionary(Int32, Utf8("m0")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                          Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                            Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                              Projection: make_array(CASE WHEN many_measurements > Int32(0) THEN Utf8("many_measurements") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                                Aggregate: groupBy=[[]], aggr=[[sum(CAST(m0.many_measurements IS NOT NULL AS UInt64)) AS many_measurements]] [many_measurements:UInt64;N]
                                  Filter: m0.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                                    TableScan: m0 [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                      Projection: Dictionary(Int32, Utf8("m1")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                        Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                          Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                            Projection: make_array(CASE WHEN many_measurements > Int32(0) THEN Utf8("many_measurements") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                              Aggregate: groupBy=[[]], aggr=[[sum(CAST(m1.many_measurements IS NOT NULL AS UInt64)) AS many_measurements]] [many_measurements:UInt64;N]
                                Filter: m1.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                                  TableScan: m1 [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                    Projection: Dictionary(Int32, Utf8("m2")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                      Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                        Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                          Projection: make_array(CASE WHEN many_measurements > Int32(0) THEN Utf8("many_measurements") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                            Aggregate: groupBy=[[]], aggr=[[sum(CAST(m2.many_measurements IS NOT NULL AS UInt64)) AS many_measurements]] [many_measurements:UInt64;N]
                              Filter: m2.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                                TableScan: m2 [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                  Projection: Dictionary(Int32, Utf8("m3")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                    Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                      Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                        Projection: make_array(CASE WHEN many_measurements > Int32(0) THEN Utf8("many_measurements") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                          Aggregate: groupBy=[[]], aggr=[[sum(CAST(m3.many_measurements IS NOT NULL AS UInt64)) AS many_measurements]] [many_measurements:UInt64;N]
                            Filter: m3.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                              TableScan: m3 [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                Projection: Dictionary(Int32, Utf8("m4")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                  Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                    Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                      Projection: make_array(CASE WHEN many_measurements > Int32(0) THEN Utf8("many_measurements") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                        Aggregate: groupBy=[[]], aggr=[[sum(CAST(m4.many_measurements IS NOT NULL AS UInt64)) AS many_measurements]] [many_measurements:UInt64;N]
                          Filter: m4.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                            TableScan: m4 [f64_field:Float64;N, many_measurements:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
              Projection: Dictionary(Int32, Utf8("merge_00")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
                Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                  Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                    Projection: make_array(CASE WHEN col0 > Int32(0) THEN Utf8("col0") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                      Aggregate: groupBy=[[]], aggr=[[sum(CAST(merge_00.col0 IS NOT NULL AS UInt64)) AS col0]] [col0:UInt64;N]
                        Filter: merge_00.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [col0:Dictionary(Int32, Utf8);N, col1:Float64;N, col2:Boolean;N, col3:Utf8;N, time:Timestamp(Nanosecond, None)]
                          TableScan: merge_00 [col0:Dictionary(Int32, Utf8);N, col1:Float64;N, col2:Boolean;N, col3:Utf8;N, time:Timestamp(Nanosecond, None)]
            Projection: Dictionary(Int32, Utf8("merge_01")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
              Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
                Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                  Projection: make_array(CASE WHEN col1 > Int32(0) THEN Utf8("col1") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                    Aggregate: groupBy=[[]], aggr=[[sum(CAST(merge_01.col1 IS NOT NULL AS UInt64)) AS col1]] [col1:UInt64;N]
                      Filter: merge_01.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [col0:Float64;N, col1:Dictionary(Int32, Utf8);N, col2:Utf8;N, col3:Boolean;N, time:Timestamp(Nanosecond, None)]
                        TableScan: merge_01 [col0:Float64;N, col1:Dictionary(Int32, Utf8);N, col2:Utf8;N, col3:Boolean;N, time:Timestamp(Nanosecond, None)]
          Projection: Dictionary(Int32, Utf8("name_clash")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
            Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
              Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
                Projection: make_array(CASE WHEN first > Int32(0) THEN Utf8("first") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                  Aggregate: groupBy=[[]], aggr=[[sum(CAST(name_clash.first IS NOT NULL AS UInt64)) AS first]] [first:UInt64;N]
                    Filter: name_clash.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [f:Float64;N, first:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                      TableScan: name_clash [f:Float64;N, first:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
        Projection: Dictionary(Int32, Utf8("temp_01")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
          Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
            Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
              Projection: make_array(CASE WHEN shared_tag0 > Int32(0) THEN Utf8("shared_tag0") END, CASE WHEN shared_tag1 > Int32(0) THEN Utf8("shared_tag1") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
                Aggregate: groupBy=[[]], aggr=[[sum(CAST(temp_01.shared_tag0 IS NOT NULL AS UInt64)) AS shared_tag0, sum(CAST(temp_01.shared_tag1 IS NOT NULL AS UInt64)) AS shared_tag1]] [shared_tag0:UInt64;N, shared_tag1:UInt64;N]
                  Filter: temp_01.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [field_f64:Float64;N, field_i64:Int64;N, field_str:Utf8;N, field_u64:UInt64;N, shared_field0:Float64;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                    TableScan: temp_01 [field_f64:Float64;N, field_i64:Int64;N, field_str:Utf8;N, field_u64:UInt64;N, shared_field0:Float64;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
      Projection: Dictionary(Int32, Utf8("temp_02")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
        Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
          Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
            Projection: make_array(CASE WHEN shared_tag0 > Int32(0) THEN Utf8("shared_tag0") END, CASE WHEN shared_tag1 > Int32(0) THEN Utf8("shared_tag1") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
              Aggregate: groupBy=[[]], aggr=[[sum(CAST(temp_02.shared_tag0 IS NOT NULL AS UInt64)) AS shared_tag0, sum(CAST(temp_02.shared_tag1 IS NOT NULL AS UInt64)) AS shared_tag1]] [shared_tag0:UInt64;N, shared_tag1:UInt64;N]
                Filter: temp_02.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [shared_field0:Int64;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                  TableScan: temp_02 [shared_field0:Int64;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
    Projection: Dictionary(Int32, Utf8("temp_03")) AS iox::measurement, tagKey [iox::measurement:Dictionary(Int32, Utf8), tagKey:Utf8;N]
      Filter: tagKey IS NOT NULL [tagKey:Utf8;N]
        Unnest: lists[tagKey|depth=1] structs[] [tagKey:Utf8;N]
          Projection: make_array(CASE WHEN shared_tag0 > Int32(0) THEN Utf8("shared_tag0") END, CASE WHEN shared_tag1 > Int32(0) THEN Utf8("shared_tag1") END) AS tagKey [tagKey:List(Field { name: "item", data_type: Utf8, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} });N]
            Aggregate: groupBy=[[]], aggr=[[sum(CAST(temp_03.shared_tag0 IS NOT NULL AS UInt64)) AS shared_tag0, sum(CAST(temp_03.shared_tag1 IS NOT NULL AS UInt64)) AS shared_tag1]] [shared_tag0:UInt64;N, shared_tag1:UInt64;N]
              Filter: temp_03.time >= TimestampNanosecond(1672444800000000000, None) AND Boolean(false) [shared_field0:Utf8;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
                TableScan: temp_03 [shared_field0:Utf8;N, shared_tag0:Dictionary(Int32, Utf8);N, shared_tag1:Dictionary(Int32, Utf8);N, time:Timestamp(Nanosecond, None)]
